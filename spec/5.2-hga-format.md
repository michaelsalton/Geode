# Spec 5.2: HGA Format

**Module:** Conversion Engine
**Phase:** 5 - Conversion & Packaging
**Week:** 13

## Overview

Design and implement the Hybrid Gaussian Asset (.hga) binary container format that packages mesh geometry, Gaussian splat data, and metadata into a single file for game engine consumption.

## File Structure

```
┌─────────────────────────────────────┐
│            HEADER (64 bytes)        │
├─────────────────────────────────────┤
│        CHUNK OFFSET TABLE           │
├─────────────────────────────────────┤
│          METADATA CHUNK             │
├─────────────────────────────────────┤
│            MESH CHUNK               │
├─────────────────────────────────────┤
│          GAUSSIAN CHUNK             │
├─────────────────────────────────────┤
│         CLUSTER MAP CHUNK           │
├─────────────────────────────────────┤
│      BOUNDARY CHUNK (optional)      │
└─────────────────────────────────────┘
```

## Header Format

```cpp
struct HGAHeader {
    char magic[4];           // "HGA1"
    uint32_t version;        // Format version (1)
    uint64_t file_size;      // Total file size in bytes
    uint32_t chunk_count;    // Number of chunks
    uint32_t flags;          // Compression flags, etc.
    uint8_t reserved[44];    // Padding to 64 bytes
};
```

### Flags

| Bit | Meaning |
|-----|---------|
| 0 | Mesh chunk compressed (gzip) |
| 1 | Gaussian chunk compressed (gzip) |
| 2 | Mesh uses Draco compression |
| 3-31 | Reserved |

## Chunk Offset Table

```cpp
struct ChunkEntry {
    uint32_t type;           // Chunk type ID
    uint32_t flags;          // Per-chunk flags
    uint64_t offset;         // Byte offset from file start
    uint64_t size;           // Chunk size in bytes
    uint64_t uncompressed_size;  // Original size if compressed
};
```

### Chunk Types

| ID | Type | Description |
|----|------|-------------|
| 0x4D455441 | META | Metadata |
| 0x4D455348 | MESH | Triangle mesh |
| 0x47415553 | GAUS | Gaussian splats |
| 0x434C5354 | CLST | Cluster map |
| 0x424E4459 | BNDY | Boundary blend zones |

## Metadata Chunk

JSON-encoded metadata:

```json
{
    "asset_name": "scene_001",
    "source_file": "scene.ply",
    "geode_version": "1.0.0",
    "creation_timestamp": "2026-02-15T10:30:00Z",
    "classification_config": {
        "planarity_threshold": 0.7,
        "erank_mean_low": 1.8,
        "erank_mean_high": 2.2,
        "alpha_mean_threshold": 0.85,
        "alpha_variance_threshold": 0.1,
        "normal_coherence_threshold": 0.7
    },
    "bounds": {
        "min": [-10.0, -5.0, 0.0],
        "max": [10.0, 5.0, 3.0]
    },
    "statistics": {
        "total_gaussians": 50000,
        "mesh_gaussians": 22000,
        "retained_gaussians": 28000,
        "mesh_vertices": 15000,
        "mesh_triangles": 28000,
        "cluster_count": 42
    }
}
```

## Mesh Chunk

Binary mesh data:

```cpp
struct MeshChunkHeader {
    uint32_t vertex_count;
    uint32_t triangle_count;
    uint32_t attribute_flags;   // Which attributes present
    uint8_t reserved[20];
};

// Attribute flags
enum MeshAttributes {
    HAS_NORMALS = 1 << 0,
    HAS_COLORS  = 1 << 1,
    HAS_UVS     = 1 << 2,
};

// Data layout (tightly packed):
// float3 positions[vertex_count]
// float3 normals[vertex_count]      (if HAS_NORMALS)
// uint8_t colors[vertex_count * 3]  (if HAS_COLORS, RGB)
// float2 uvs[vertex_count]          (if HAS_UVS)
// uint32_t indices[triangle_count * 3]
```

## Gaussian Chunk

Binary Gaussian data (subset of original):

```cpp
struct GaussianChunkHeader {
    uint32_t gaussian_count;
    uint32_t sh_degree;         // 0-3, determines coefficient count
    uint8_t reserved[24];
};

// Data layout per Gaussian (tightly packed):
// float3 position
// float3 scale
// float4 rotation (quaternion)
// float opacity
// float sh_coefficients[3 * (sh_degree + 1)^2]
```

## Cluster Map Chunk

Debug/LOD information:

```cpp
struct ClusterMapHeader {
    uint32_t cluster_count;
    uint8_t reserved[28];
};

struct ClusterRecord {
    uint32_t id;
    uint32_t label;              // 0=mesh, 1=gaussian, 2=uncertain
    float confidence;
    float bounds_min[3];
    float bounds_max[3];
    uint32_t primitive_start;    // Index into primitive list
    uint32_t primitive_count;
    // Metrics for debugging
    float planarity;
    float erank_mean;
    float alpha_mean;
    float normal_coherence;
};
```

## Boundary Chunk (Optional)

For smooth mesh-Gaussian transitions:

```cpp
struct BoundaryRecord {
    uint32_t mesh_cluster_id;
    uint32_t gaussian_cluster_id;
    float blend_width;           // World-space blend distance
    uint32_t vertex_start;       // Affected mesh vertices
    uint32_t vertex_count;
};
```

## Requirements

### Functional

- [ ] Write HGA files with all required chunks
- [ ] Read HGA files and reconstruct data structures
- [ ] Support optional compression (gzip per-chunk)
- [ ] Validate file integrity on load
- [ ] Version compatibility checking

### Performance

- [ ] Write 50K mesh + 50K Gaussians in < 2 seconds
- [ ] Read same file in < 500ms
- [ ] Memory-mappable for streaming

### Compatibility

- [ ] Little-endian byte order
- [ ] 8-byte alignment for chunks
- [ ] Forward-compatible (ignore unknown chunks)

## API

```cpp
namespace geode {

class HGAWriter {
public:
    struct Options {
        bool compress_mesh = false;
        bool compress_gaussians = false;
        bool use_draco = false;
        int draco_compression_level = 7;
    };

    void write(const std::filesystem::path& path,
               const Mesh& mesh,
               const std::vector<Primitive>& gaussians,
               const std::vector<ClassificationResult>& clusters,
               const HGAMetadata& metadata,
               const Options& options = {});
};

class HGAReader {
public:
    struct HGAAsset {
        HGAMetadata metadata;
        Mesh mesh;
        std::vector<Primitive> gaussians;
        std::vector<ClusterRecord> clusters;
    };

    HGAAsset read(const std::filesystem::path& path);

    // Partial loading
    HGAMetadata read_metadata(const std::filesystem::path& path);
    Mesh read_mesh(const std::filesystem::path& path);
    std::vector<Primitive> read_gaussians(const std::filesystem::path& path);
};

}  // namespace geode
```

## File Size Estimates

| Component | Uncompressed | Compressed |
|-----------|--------------|------------|
| Header + Offsets | ~200 bytes | ~200 bytes |
| Metadata | ~1 KB | ~500 bytes |
| Mesh (10K verts, 20K tris) | ~600 KB | ~200 KB |
| Gaussians (30K) | ~7 MB | ~3 MB |
| Cluster Map (50 clusters) | ~5 KB | ~2 KB |
| **Total** | **~8 MB** | **~3.5 MB** |

## Test Cases

| Test | Action | Expected |
|------|--------|----------|
| Round-trip | Write then read | Identical data |
| Empty mesh | No MESH_OPTIMAL clusters | Valid file, empty mesh chunk |
| Compression | Enable gzip | Smaller file, same data |
| Large file | 1M Gaussians | Handles without OOM |
| Corrupt file | Truncated file | Error on load |
| Version mismatch | Future version | Warning, best-effort load |

## Game Engine Integration

### Unity

```csharp
public class HGAImporter : ScriptedImporter {
    public override void OnImportAsset(AssetImportContext ctx) {
        // Read HGA, create Mesh + GaussianSplatAsset
    }
}
```

### Unreal

```cpp
class UHGAFactory : public UFactory {
    UObject* FactoryCreateBinary(...) override {
        // Read HGA, create UStaticMesh + UGaussianSplatComponent
    }
};
```

## Notes

- Format designed for fast GPU upload (DMA-friendly layout)
- Chunk-based design allows partial loading and streaming
- Consider adding LOD meshes in future versions
- Gaussian data preserves all fields for potential re-classification
