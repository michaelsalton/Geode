# Spec 5.1: Mesh Extraction

**Module:** Conversion Engine
**Phase:** 5 - Conversion & Packaging
**Week:** 12

## Overview

Convert MESH_OPTIMAL clusters to triangle meshes using Screened Poisson Surface Reconstruction, then clean up and transfer colors from the source Gaussians.

## Input

```cpp
struct ClassificationResult {
    ClusterLabel label;  // MESH_OPTIMAL
    std::vector<uint32_t> primitive_indices;
    // ...
};

std::vector<Primitive> primitives;  // Source Gaussians
```

## Output

```cpp
struct Mesh {
    std::vector<Eigen::Vector3f> vertices;
    std::vector<Eigen::Vector3f> normals;
    std::vector<Eigen::Vector3f> colors;      // RGB [0,1]
    std::vector<Eigen::Vector3i> triangles;   // Vertex indices
};
```

## Pipeline

```
MESH_OPTIMAL Cluster
        │
        ▼
┌───────────────────┐
│ Prepare Oriented  │  Collect positions + normals
│ Point Cloud       │  Orient normals consistently
└───────────────────┘
        │
        ▼
┌───────────────────┐
│ Poisson Surface   │  Screened Poisson (depth 8)
│ Reconstruction    │
└───────────────────┘
        │
        ▼
┌───────────────────┐
│ Mesh Cleanup      │  Trim, decimate, remove degenerates
└───────────────────┘
        │
        ▼
┌───────────────────┐
│ Color Transfer    │  k-NN interpolation from SH DC
└───────────────────┘
        │
        ▼
     Mesh Output
```

## Algorithms

### 1. Oriented Point Cloud Preparation

```cpp
struct OrientedPoint {
    Eigen::Vector3f position;
    Eigen::Vector3f normal;
};

std::vector<OrientedPoint> prepare_oriented_cloud(
    const Cluster& cluster,
    const std::vector<Primitive>& primitives)
{
    std::vector<OrientedPoint> points;
    points.reserve(cluster.primitive_indices.size());

    for (uint32_t idx : cluster.primitive_indices) {
        const auto& p = primitives[idx];
        points.push_back({p.position, p.normal});
    }

    orient_normals_consistently(points);  // Propagate orientation
    return points;
}
```

### 2. Poisson Surface Reconstruction

Using CGAL or Open3D:

```cpp
Mesh poisson_reconstruct(const std::vector<OrientedPoint>& points,
                          const PoissonConfig& config)
{
    // CGAL approach
    CGAL::poisson_surface_reconstruction_delaunay(
        points.begin(), points.end(),
        Point_map(), Normal_map(),
        output_mesh,
        config.spacing,           // Point spacing estimate
        config.sm_angle,          // Min triangle angle (20°)
        config.sm_radius,         // Max surface radius
        config.sm_distance        // Max distance to surface
    );

    // Trim mesh at density threshold
    trim_mesh(output_mesh, config.trim_threshold);

    return convert_to_mesh(output_mesh);
}
```

#### Poisson Parameters

| Parameter | Default | Description |
|-----------|---------|-------------|
| depth | 8 | Octree depth (higher = more detail) |
| scale | 1.1 | Bounding box scale factor |
| samplesPerNode | 1.5 | Min samples per octree node |
| trim_threshold | 7.0 | Density trimming threshold |

### 3. Mesh Cleanup

```cpp
void cleanup_mesh(Mesh& mesh, const CleanupConfig& config) {
    // 1. Remove degenerate triangles (zero area)
    remove_degenerate_triangles(mesh, config.min_area);

    // 2. Remove small disconnected components
    remove_small_components(mesh, config.min_component_vertices);

    // 3. Decimate if over target
    if (mesh.vertices.size() > config.max_vertices) {
        decimate_mesh(mesh, config.max_vertices);
    }

    // 4. Recompute normals
    recompute_vertex_normals(mesh);
}
```

#### Cleanup Parameters

| Parameter | Default | Description |
|-----------|---------|-------------|
| min_area | 1e-8 | Min triangle area |
| min_component_vertices | 10 | Remove components smaller than this |
| max_vertices | 50000 | Target for decimation |
| decimation_ratio | 0.5 | Reduction per decimation pass |

### 4. Color Transfer

Transfer colors from source Gaussians using inverse-distance weighted k-NN:

```cpp
void transfer_colors(Mesh& mesh,
                     const std::vector<Primitive>& primitives,
                     const std::vector<uint32_t>& source_indices,
                     int k = 5)
{
    // Build k-d tree from source Gaussian positions
    KDTree tree(primitives, source_indices);

    for (size_t i = 0; i < mesh.vertices.size(); ++i) {
        auto neighbors = tree.knn_search(mesh.vertices[i], k);

        Eigen::Vector3f color = Eigen::Vector3f::Zero();
        float total_weight = 0.0f;

        for (const auto& [idx, dist] : neighbors) {
            float weight = 1.0f / (dist + 1e-6f);
            color += weight * sh_dc_to_rgb(primitives[idx].sh_coefficients);
            total_weight += weight;
        }

        mesh.colors[i] = color / total_weight;
    }
}
```

## Requirements

### Functional

- [ ] Prepare oriented point cloud from cluster
- [ ] Orient normals consistently (propagation)
- [ ] Run Poisson surface reconstruction
- [ ] Trim mesh at density threshold
- [ ] Remove degenerate triangles
- [ ] Remove small disconnected components
- [ ] Decimate oversized meshes
- [ ] Transfer colors via k-NN interpolation
- [ ] Process clusters independently (parallelizable)

### Quality

- [ ] Watertight meshes where possible
- [ ] Smooth surfaces without excessive artifacts
- [ ] Colors match source Gaussians visually

### Performance

- [ ] Per-cluster extraction < 2 seconds
- [ ] Total conversion (20 clusters) < 30 seconds
- [ ] Memory < 500MB per cluster

## Configuration

```cpp
struct MeshExtractionConfig {
    // Poisson
    int poisson_depth = 8;
    float poisson_scale = 1.1f;
    float trim_threshold = 7.0f;

    // Cleanup
    float min_triangle_area = 1e-8f;
    int min_component_vertices = 10;
    int max_vertices_per_cluster = 50000;

    // Color transfer
    int color_knn = 5;
};
```

## API

```cpp
namespace geode {

class MeshExtractor {
public:
    explicit MeshExtractor(const MeshExtractionConfig& config = {});

    // Extract mesh from single cluster
    Mesh extract(const Cluster& cluster,
                 const std::vector<Primitive>& primitives);

    // Extract and merge all MESH_OPTIMAL clusters
    Mesh extract_all(const std::vector<ClassificationResult>& results,
                     const std::vector<Primitive>& primitives);

private:
    MeshExtractionConfig config_;
};

}  // namespace geode
```

## Test Cases

| Test | Input | Expected |
|------|-------|----------|
| Flat plane | Planar cluster | Single quad-like mesh |
| Curved surface | Hemisphere cluster | Smooth curved mesh |
| Thin surface | Wall cluster | Two-sided mesh |
| Low density | 50 points | Coarse but valid mesh |
| High density | 5000 points | Detailed mesh, decimated |
| Colors | Varied SH DC | Smooth color gradient |

## Failure Modes

| Issue | Detection | Fallback |
|-------|-----------|----------|
| Poisson fails | Exception / empty mesh | Skip cluster, keep as Gaussian |
| Non-manifold | Topology check | Attempt repair or skip |
| Poor normals | High coherence variance | Use Poisson-derived normals |

## Notes

- MESH_OPTIMAL clusters are pre-filtered for flatness, improving Poisson success
- Poisson depth 8 balances detail vs. speed; increase for archviz quality
- Color transfer assumes SH DC is view-independent approximation of color
- Consider vertex color quantization for smaller file sizes
