# Spec 2.1: Spatial Clustering

**Module:** Clustering Engine
**Phase:** 1 - Foundation
**Week:** 3

## Overview

Partition Primitives into spatially coherent clusters using k-means with spatial hash acceleration. Clusters serve as the unit of analysis for classification.

## Input

```cpp
struct Scene {
    std::vector<Primitive> primitives;
    Eigen::AlignedBox3f bounds;
    // ...
};
```

## Output

```cpp
struct Cluster {
    uint32_t id;
    std::vector<uint32_t> primitive_indices;
    Eigen::AlignedBox3f bounds;
    Eigen::Vector3f centroid;
    uint32_t primitive_count;
};

std::vector<Cluster> cluster_scene(const Scene& scene, const ClusterConfig& config);
```

## Algorithm

### Step 1: Build Spatial Hash Grid

```cpp
struct SpatialHashGrid {
    float cell_size;  // extent / grid_resolution
    std::unordered_map<GridCell, std::vector<uint32_t>> cells;

    std::vector<uint32_t> query_neighbors(const Eigen::Vector3f& pos, float radius);
};
```

- Default grid resolution: 64 cells per axis
- Cell size = `max_extent / grid_resolution`
- O(1) neighbor lookup for k-means assignment

### Step 2: Determine k

```cpp
int k = total_primitives / target_cluster_size;
k = std::clamp(k, 4, total_primitives / 50);
```

- Default `target_cluster_size`: 500 primitives

### Step 3: K-means++ Initialization

1. Choose first centroid uniformly at random
2. For each subsequent centroid:
   - Compute D(x) = distance to nearest existing centroid
   - Choose new centroid with probability ∝ D(x)²

### Step 4: K-means Iteration

```
repeat:
    // Assignment pass
    for each primitive p:
        assign p to nearest centroid

    // Update pass
    for each cluster c:
        c.centroid = mean(assigned primitive positions)

until convergence or max_iterations
```

Convergence: centroid movement < ε (default: 0.001 × scene extent)

### Step 5: Cluster Balancing

**Merge underweight clusters:**
- Flag clusters with count < `target_size / 5`
- Transfer primitives to nearest non-flagged cluster

**Split overweight clusters:**
- Flag clusters with count > `target_size × 3`
- Run k-means locally with k=2

### Step 6: Compute Cluster Metadata

For each cluster:
- Bounding box from member positions
- Centroid = mean position
- Primitive count

## Configuration

```cpp
struct ClusterConfig {
    int target_cluster_size = 500;
    int grid_resolution = 64;
    int max_iterations = 100;
    float convergence_epsilon = 0.001f;  // relative to extent
    int min_cluster_size_factor = 5;     // target / factor
    int max_cluster_size_factor = 3;     // target × factor
};
```

## Requirements

### Functional

- [ ] Build spatial hash grid for O(1) neighbor queries
- [ ] Implement k-means++ initialization
- [ ] Implement k-means iteration with convergence check
- [ ] Merge underweight clusters
- [ ] Split overweight clusters
- [ ] Compute per-cluster metadata

### Performance

- [ ] Cluster 1M primitives in < 5 seconds
- [ ] Spatial hash queries in O(1) average case
- [ ] Parallelize assignment pass with OpenMP

### Debug Output

- [ ] Export colored point cloud (one color per cluster)
- [ ] Log cluster size distribution statistics

## Test Cases

| Test | Input | Expected |
|------|-------|----------|
| Uniform grid | 10K points in cube | ~20 balanced clusters |
| Two blobs | 5K + 5K separated | 2 distinct cluster groups |
| Single point | 1 primitive | 1 cluster |
| Tiny clusters | 100 points, target=500 | Merged into 1-2 clusters |
| Large cluster | 5K points clumped | Split into multiple |

## API

```cpp
namespace geode {

class ClusteringEngine {
public:
    explicit ClusteringEngine(const ClusterConfig& config = {});

    std::vector<Cluster> cluster(const Scene& scene);

    // Debug
    void export_colored_ply(const std::string& path,
                            const Scene& scene,
                            const std::vector<Cluster>& clusters);
};

}  // namespace geode
```

## Notes

- Position-only clustering (normals/eigenvalues not used in distance)
- Future enhancement: normal-weighted distance for boundary refinement
- Cluster IDs are stable within a run but not across runs (random initialization)
