# Spec 1.2: Primitive Representation

**Module:** Ingestion
**Phase:** 1 - Foundation
**Week:** 2

## Overview

Transform raw Gaussian data into enriched Primitive structs with reconstructed covariance matrices, derived normals, eigenvalues, and effective rank.

## Input

```cpp
struct RawGaussian {
    Eigen::Vector3f position;
    Eigen::Vector3f scale;
    Eigen::Quaternionf rotation;
    float opacity;
    std::array<float, 48> sh_coefficients;
};
```

## Output

```cpp
struct Primitive {
    Eigen::Vector3f position;
    Eigen::Matrix3f covariance;      // Reconstructed 3x3 covariance
    Eigen::Vector3f eigenvalues;     // λ₁ >= λ₂ >= λ₃
    Eigen::Vector3f normal;          // Smallest eigenvector
    float alpha;                     // Opacity
    float effective_rank;            // exp(H(q₁, q₂, q₃))
    std::array<float, 48> sh_coefficients;
};
```

## Algorithms

### Covariance Reconstruction

From scale `s` and rotation quaternion `q`:

```
R = quaternion_to_matrix(q)
S = diag(s₀, s₁, s₂)
Σ = R · S · Sᵀ · Rᵀ
```

### Eigendecomposition

Compute eigenvalues and eigenvectors of Σ using `Eigen::SelfAdjointEigenSolver`:
- Sort eigenvalues descending: λ₁ >= λ₂ >= λ₃
- Normal vector = eigenvector corresponding to λ₃ (smallest)

### Effective Rank

Measures the "dimensionality" of the Gaussian shape:

```
// Normalize eigenvalues to probabilities
sum = λ₁ + λ₂ + λ₃
q₁ = λ₁ / sum
q₂ = λ₂ / sum
q₃ = λ₃ / sum

// Shannon entropy
H = -Σ qᵢ · log(qᵢ)  // for qᵢ > 0

// Effective rank
erank = exp(H)
```

| Shape | Effective Rank |
|-------|----------------|
| Sphere (λ₁ ≈ λ₂ ≈ λ₃) | ~3.0 |
| Disk (λ₁ ≈ λ₂ >> λ₃) | ~2.0 |
| Line (λ₁ >> λ₂ ≈ λ₃) | ~1.0 |

## Requirements

### Functional

- [ ] Reconstruct covariance matrix from scale + rotation
- [ ] Compute eigendecomposition with sorted eigenvalues
- [ ] Derive normal vector from smallest eigenvector
- [ ] Compute effective rank per Gaussian
- [ ] Handle degenerate cases (zero eigenvalues)

### Scene Metadata

- [ ] Compute axis-aligned bounding box
- [ ] Compute scene centroid
- [ ] Compute spatial extent per axis
- [ ] Store total primitive count

### Performance

- [ ] Process 1M Gaussians in < 3 seconds
- [ ] Parallelize with OpenMP where beneficial
- [ ] Cache-friendly memory layout (SoA vs AoS consideration)

## Data Structures

```cpp
namespace geode {

struct Scene {
    std::vector<Primitive> primitives;

    // Metadata
    Eigen::AlignedBox3f bounds;
    Eigen::Vector3f centroid;
    Eigen::Vector3f extent;
    size_t primitive_count;

    // Factory
    static Scene from_raw_gaussians(std::span<const RawGaussian> raw);
};

}  // namespace geode
```

## Test Cases

| Test | Input | Expected |
|------|-------|----------|
| Identity rotation | q = (1,0,0,0), s = (1,2,3) | Σ = diag(1,4,9) |
| Sphere | s = (1,1,1) | erank ≈ 3.0 |
| Disk | s = (1,1,0.01) | erank ≈ 2.0, normal along z |
| Line | s = (1,0.01,0.01) | erank ≈ 1.0 |
| Rotated disk | 45° rotation | Normal correctly rotated |

## Notes

- Eigenvalues are stored as squared scales (variance), not standard deviations
- Normal orientation is arbitrary (±); coherence metrics use absolute dot product
- Effective rank is continuous, allowing soft classification boundaries
