# Spec 3.1: PCA Analysis

**Module:** Labeling Engine
**Phase:** 2 - Classification Metrics
**Week:** 4

## Overview

Compute cluster-level geometric features using Principal Component Analysis on primitive positions. These features characterize the spatial distribution of Gaussians within each cluster.

## Input

```cpp
struct Cluster {
    std::vector<uint32_t> primitive_indices;
    // ...
};

std::vector<Primitive> primitives;  // From scene
```

## Output

```cpp
struct PCAMetrics {
    Eigen::Vector3f eigenvalues;  // Λ₁ >= Λ₂ >= Λ₃
    float planarity;              // (Λ₂ - Λ₃) / Λ₁
    float linearity;              // (Λ₁ - Λ₂) / Λ₁
    float sphericity;             // Λ₃ / Λ₁
    float surface_variation;      // Λ₃ / (Λ₁ + Λ₂ + Λ₃)
};
```

## Algorithm

### Step 1: Gather Positions

Collect positions of all primitives in the cluster:
```cpp
std::vector<Eigen::Vector3f> positions;
for (uint32_t idx : cluster.primitive_indices) {
    positions.push_back(primitives[idx].position);
}
```

### Step 2: Compute Covariance Matrix

```cpp
// Center the points
Eigen::Vector3f mean = compute_mean(positions);
for (auto& p : positions) p -= mean;

// Build 3x3 covariance matrix
Eigen::Matrix3f cov = Eigen::Matrix3f::Zero();
for (const auto& p : positions) {
    cov += p * p.transpose();
}
cov /= positions.size();
```

### Step 3: Eigendecomposition

```cpp
Eigen::SelfAdjointEigenSolver<Eigen::Matrix3f> solver(cov);
Eigen::Vector3f eigenvalues = solver.eigenvalues().reverse();  // Sort descending
```

### Step 4: Compute Geometric Features

| Metric | Formula | Interpretation |
|--------|---------|----------------|
| **Planarity** | (Λ₂ - Λ₃) / Λ₁ | High = points lie on a plane |
| **Linearity** | (Λ₁ - Λ₂) / Λ₁ | High = points lie on a line |
| **Sphericity** | Λ₃ / Λ₁ | High = isotropic distribution |
| **Surface Variation** | Λ₃ / ΣΛ | Low = surface-like |

### Geometric Interpretation

```
                    Linearity
                       ↑
                       |
            Line ●     |
                 \     |
                  \    |
                   \   |
                    \  |
                     \ |
  Planarity ←─────────●─────────→ Sphericity
                    / |
                   /  |
                  /   |
                 /    |
           Plane ●    |
                      |
                      ↓
```

## Requirements

### Functional

- [ ] Compute position covariance matrix per cluster
- [ ] Perform eigendecomposition with sorted eigenvalues
- [ ] Compute planarity metric
- [ ] Compute linearity metric
- [ ] Compute sphericity metric
- [ ] Compute surface variation metric

### Edge Cases

- [ ] Handle clusters with < 3 points (undefined PCA)
- [ ] Handle degenerate covariance (zero eigenvalues)
- [ ] Clamp metrics to [0, 1] range

### Performance

- [ ] Process 1000 clusters in < 500ms
- [ ] Parallelize across clusters

## Test Cases

| Test | Input | Expected |
|------|-------|----------|
| Flat plane | Points on z=0 | planarity > 0.9, Λ₃ ≈ 0 |
| Line | Points on x-axis | linearity > 0.9 |
| Sphere | Points on sphere surface | sphericity > 0.3 |
| Cube volume | Random in cube | sphericity ≈ 0.33 |
| 2 points | Minimal cluster | Handled gracefully |

## API

```cpp
namespace geode {

struct PCAMetrics {
    Eigen::Vector3f eigenvalues;
    float planarity;
    float linearity;
    float sphericity;
    float surface_variation;

    static PCAMetrics compute(std::span<const Eigen::Vector3f> positions);
};

}  // namespace geode
```

## Classification Relevance

**Mesh-optimal indicators:**
- High planarity (> 0.7) → surface-like distribution
- Low surface variation → consistent surface

**Gaussian-optimal indicators:**
- High sphericity → volumetric/fuzzy region
- Mixed linearity → complex geometry

## Notes

- This analyzes the *positions* of Gaussians, not their individual covariances
- Complements per-Gaussian effective rank (Spec 1.2) which analyzes shape
- Planarity is the primary PCA-based signal for mesh classification
