# Spec 3.3: Normal Coherence

**Module:** Labeling Engine
**Phase:** 2 - Classification Metrics
**Week:** 5

## Overview

Measure how consistently the derived normals within a cluster point in the same direction. High coherence indicates a well-defined surface orientation suitable for mesh representation.

## Input

```cpp
struct Cluster {
    std::vector<uint32_t> primitive_indices;
};

std::vector<Primitive> primitives;  // Each has .normal field (unit vector)
```

## Output

```cpp
struct NormalCoherenceMetrics {
    float coherence;           // Average alignment with mean normal [0, 1]
    Eigen::Vector3f mean_normal;  // Dominant normal direction
};
```

## Algorithm

### Step 1: Compute Mean Normal Direction

```cpp
Eigen::Vector3f sum = Eigen::Vector3f::Zero();
for (uint32_t idx : cluster.primitive_indices) {
    sum += primitives[idx].normal;
}
Eigen::Vector3f mean_normal = sum.normalized();
```

Note: Simple averaging works because we use absolute dot product later, handling normal flipping.

### Step 2: Compute Coherence Score

```cpp
float coherence_sum = 0.0f;
for (uint32_t idx : cluster.primitive_indices) {
    // Absolute dot product handles normal direction ambiguity
    float alignment = std::abs(primitives[idx].normal.dot(mean_normal));
    coherence_sum += alignment;
}
float coherence = coherence_sum / cluster.primitive_indices.size();
```

### Why Absolute Dot Product?

Normals derived from eigendecomposition have arbitrary sign (±). A flat wall might have half the normals pointing "in" and half pointing "out":

```
Without abs():  (-1 + -1 + 1 + 1) / 4 = 0.0  ← Wrong!
With abs():     (1 + 1 + 1 + 1) / 4 = 1.0    ← Correct!
```

## Interpretation

| Coherence | Interpretation | Example |
|-----------|----------------|---------|
| > 0.9 | Strong surface | Flat wall, floor |
| 0.7 - 0.9 | Curved surface | Cylinder, dome |
| 0.5 - 0.7 | Complex geometry | Corners, edges |
| < 0.5 | No dominant surface | Foliage, particles |

### Visual Examples

```
Flat Wall (C ≈ 1.0):
    → → → →
    → → → →
    → → → →

Curved Surface (C ≈ 0.85):
    ↗ → → ↘
    ↑ → → ↓
    ↖ → → ↙

Foliage (C ≈ 0.3):
    ↗ ↓ ← ↑
    → ↖ ↘ ↙
    ↓ ↗ ↑ ←
```

## Requirements

### Functional

- [ ] Compute mean normal direction (unnormalized sum, then normalize)
- [ ] Compute coherence using absolute dot product
- [ ] Handle clusters with < 2 primitives (coherence = 1.0)
- [ ] Handle zero-length mean normal (degenerate case)

### Performance

- [ ] Process 1000 clusters in < 50ms
- [ ] Vectorizable inner loop

## Test Cases

| Test | Input Normals | Expected |
|------|---------------|----------|
| All parallel | [(0,0,1), (0,0,1), (0,0,1)] | C = 1.0 |
| Opposite | [(0,0,1), (0,0,-1)] | C = 1.0 (abs dot) |
| Perpendicular | [(1,0,0), (0,1,0), (0,0,1)] | C ≈ 0.577 |
| Random unit | Random directions | C ≈ 0.5 |
| Single | [(1,0,0)] | C = 1.0 |

## API

```cpp
namespace geode {

struct NormalCoherenceMetrics {
    float coherence = 0.0f;
    Eigen::Vector3f mean_normal = Eigen::Vector3f::Zero();

    static NormalCoherenceMetrics compute(
        std::span<const Eigen::Vector3f> normals);
};

}  // namespace geode
```

## Classification Threshold

| Metric | Threshold | Direction |
|--------|-----------|-----------|
| normal_coherence | 0.7 | > for mesh |

## Relationship to Other Metrics

Normal coherence complements:
- **PCA planarity** (Spec 3.1): Planarity measures if points *lie on* a plane; coherence measures if they *face* the same direction
- **Effective rank** (Spec 1.2): Per-Gaussian shape vs. cluster-level orientation agreement

A cluster can have:
- High planarity + low coherence: Points on a plane but with random orientations (unlikely in practice)
- Low planarity + high coherence: Points in 3D volume but all facing same way (e.g., thick wall)

## Notes

- Normals come from smallest eigenvector of per-Gaussian covariance
- Coherence is scale-invariant (only directions matter)
- Future: weight by Gaussian size/opacity for better accuracy
