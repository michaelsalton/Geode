# Spec 3.4: Classification Logic

**Module:** Labeling Engine
**Phase:** 2 - Classification Metrics
**Week:** 6

## Overview

Combine all computed metrics to classify each cluster as MESH_OPTIMAL, GAUSSIAN_OPTIMAL, or UNCERTAIN. Generate confidence scores and a classification manifest.

## Input

```cpp
struct ClusterMetrics {
    // From PCA Analysis (Spec 3.1)
    float planarity;
    float linearity;
    float sphericity;
    float surface_variation;

    // From Primitive aggregation
    float erank_mean;
    float erank_variance;

    // From Alpha Metrics (Spec 3.2)
    float alpha_mean;
    float alpha_variance;
    float alpha_min;
    float alpha_max;

    // From Normal Coherence (Spec 3.3)
    float normal_coherence;
};
```

## Output

```cpp
enum class ClusterLabel {
    MESH_OPTIMAL,
    GAUSSIAN_OPTIMAL,
    UNCERTAIN
};

struct ClassificationResult {
    ClusterLabel label;
    float confidence;           // [0, 1]
    ClusterMetrics metrics;
    uint32_t cluster_id;
    std::vector<uint32_t> primitive_indices;
};
```

## Decision Function

### Primary Classification Rule

A cluster is classified as **MESH_OPTIMAL** if ALL conditions are met:

```cpp
bool is_mesh_optimal =
    metrics.planarity > thresholds.planarity &&           // > 0.7
    metrics.erank_mean > thresholds.erank_low &&          // > 1.8
    metrics.erank_mean < thresholds.erank_high &&         // < 2.2
    metrics.alpha_mean > thresholds.alpha_mean &&         // > 0.85
    metrics.alpha_variance < thresholds.alpha_variance && // < 0.1
    metrics.normal_coherence > thresholds.normal_coherence; // > 0.7
```

Otherwise: **GAUSSIAN_OPTIMAL**

### Uncertainty Detection

If any metric is within 10% of its threshold boundary, mark as **UNCERTAIN**:

```cpp
bool near_boundary(float value, float threshold, float direction) {
    float margin = std::abs(threshold) * 0.1f;
    if (direction > 0) {  // value should be > threshold
        return value > threshold && value < threshold + margin;
    } else {  // value should be < threshold
        return value < threshold && value > threshold - margin;
    }
}
```

### Confidence Score

Confidence = minimum normalized distance from any threshold:

```cpp
float compute_confidence(const ClusterMetrics& m, const Thresholds& t) {
    std::vector<float> distances = {
        (m.planarity - t.planarity) / t.planarity,
        (m.erank_mean - t.erank_low) / t.erank_low,
        (t.erank_high - m.erank_mean) / t.erank_high,
        (m.alpha_mean - t.alpha_mean) / t.alpha_mean,
        (t.alpha_variance - m.alpha_variance) / t.alpha_variance,
        (m.normal_coherence - t.normal_coherence) / t.normal_coherence
    };

    // For MESH_OPTIMAL: all should be positive
    // Confidence is limited by the weakest metric
    return std::clamp(*std::min_element(distances.begin(), distances.end()),
                      0.0f, 1.0f);
}
```

## Threshold Configuration

```json
{
    "planarity_threshold": 0.7,
    "erank_mean_low": 1.8,
    "erank_mean_high": 2.2,
    "alpha_mean_threshold": 0.85,
    "alpha_variance_threshold": 0.1,
    "normal_coherence_threshold": 0.7,
    "uncertainty_margin": 0.1
}
```

Load from JSON file, falling back to defaults.

## Classification Manifest

Output JSON format:

```json
{
    "version": "1.0",
    "source_file": "scene.ply",
    "timestamp": "2026-02-15T10:30:00Z",
    "config": { /* thresholds used */ },
    "summary": {
        "total_clusters": 42,
        "mesh_optimal": 18,
        "gaussian_optimal": 21,
        "uncertain": 3,
        "total_primitives": 50000,
        "mesh_primitives": 22000,
        "gaussian_primitives": 28000
    },
    "clusters": [
        {
            "id": 0,
            "label": "MESH_OPTIMAL",
            "confidence": 0.85,
            "primitive_count": 523,
            "primitive_indices": [0, 1, 2, ...],
            "metrics": {
                "planarity": 0.92,
                "erank_mean": 1.95,
                "alpha_mean": 0.94,
                "alpha_variance": 0.02,
                "normal_coherence": 0.88
            }
        },
        // ...
    ]
}
```

## Requirements

### Functional

- [ ] Load threshold configuration from JSON
- [ ] Implement decision function with conjunction of conditions
- [ ] Detect UNCERTAIN clusters (within 10% of boundary)
- [ ] Compute confidence scores
- [ ] Generate classification manifest JSON
- [ ] Parallelize classification across clusters

### Validation

- [ ] All metrics in expected ranges
- [ ] Confidence in [0, 1]
- [ ] Primitive indices valid and non-overlapping

## Test Cases

| Test | Metrics | Expected |
|------|---------|----------|
| Clear mesh | P=0.95, E=2.0, α=0.95, V=0.01, C=0.9 | MESH, conf>0.8 |
| Clear Gaussian | P=0.3, E=2.8, α=0.4, V=0.2, C=0.4 | GAUSSIAN |
| Borderline | P=0.72, E=2.0, α=0.87, V=0.09, C=0.72 | UNCERTAIN |
| One fail | P=0.95, E=2.0, α=0.70, V=0.01, C=0.9 | GAUSSIAN |

## API

```cpp
namespace geode {

struct Thresholds {
    float planarity = 0.7f;
    float erank_low = 1.8f;
    float erank_high = 2.2f;
    float alpha_mean = 0.85f;
    float alpha_variance = 0.1f;
    float normal_coherence = 0.7f;
    float uncertainty_margin = 0.1f;

    static Thresholds load(const std::filesystem::path& config_path);
    static Thresholds defaults();
};

class Classifier {
public:
    explicit Classifier(const Thresholds& thresholds = Thresholds::defaults());

    ClassificationResult classify(const Cluster& cluster,
                                   const ClusterMetrics& metrics);

    void write_manifest(const std::filesystem::path& path,
                        const std::vector<ClassificationResult>& results,
                        const std::string& source_file);
};

}  // namespace geode
```

## Notes

- Conjunction (AND) logic is intentional: all signals must agree for mesh
- UNCERTAIN defaults to GAUSSIAN_OPTIMAL in conversion stage
- Thresholds are scene-type agnostic; presets may be added later
- Confidence correlates with but doesn't guarantee reconstruction quality
