# Spec 4.2: Visualization Modes

**Module:** Visualization
**Phase:** 3 - Visualization
**Week:** 8

## Overview

Implement classification visualization with color-coded labels, confidence gradients, and per-metric heat maps for debugging and validation.

## Visualization Modes

### 1. Classification Colors

Color points by their cluster's classification label:

| Label | Color | RGB |
|-------|-------|-----|
| MESH_OPTIMAL | Blue | (0.2, 0.4, 0.9) |
| GAUSSIAN_OPTIMAL | Orange | (0.9, 0.5, 0.1) |
| UNCERTAIN | Gray | (0.5, 0.5, 0.5) |

```cpp
glm::vec3 label_to_color(ClusterLabel label) {
    switch (label) {
        case ClusterLabel::MESH_OPTIMAL:
            return {0.2f, 0.4f, 0.9f};
        case ClusterLabel::GAUSSIAN_OPTIMAL:
            return {0.9f, 0.5f, 0.1f};
        case ClusterLabel::UNCERTAIN:
            return {0.5f, 0.5f, 0.5f};
    }
}
```

### 2. Confidence Gradient

Modulate color saturation by confidence:
- High confidence (1.0): Full saturation
- Low confidence (0.0): Desaturated (pale)

```cpp
glm::vec3 apply_confidence(glm::vec3 base_color, float confidence) {
    glm::vec3 gray(0.7f);
    return glm::mix(gray, base_color, confidence);
}
```

### 3. Per-Metric Heat Maps

Visualize individual metrics with color gradients:

| Metric | Low Color | High Color | Range |
|--------|-----------|------------|-------|
| Planarity | Red | Green | [0, 1] |
| Effective Rank | Blue | Yellow | [1, 3] |
| Alpha Mean | White | Black | [0, 1] |
| Alpha Variance | Green | Red | [0, 0.5] |
| Normal Coherence | Red | Green | [0, 1] |

```cpp
glm::vec3 heat_map(float value, float min_val, float max_val) {
    float t = std::clamp((value - min_val) / (max_val - min_val), 0.0f, 1.0f);
    // Viridis-like color map
    return viridis(t);
}
```

### 4. Cluster ID Colors

Assign random but distinct colors to each cluster for boundary inspection:

```cpp
glm::vec3 cluster_id_color(uint32_t cluster_id) {
    // Golden ratio hash for good color distribution
    float hue = std::fmod(cluster_id * 0.618033988749895f, 1.0f);
    return hsv_to_rgb(hue, 0.7f, 0.9f);
}
```

## UI Controls

### ImGui Panel

```cpp
void draw_visualization_panel() {
    ImGui::Begin("Visualization");

    // Mode selector
    const char* modes[] = {
        "Original Color",
        "Classification",
        "Confidence",
        "Planarity",
        "Effective Rank",
        "Alpha Mean",
        "Alpha Variance",
        "Normal Coherence",
        "Cluster ID"
    };
    ImGui::Combo("Color Mode", &current_mode, modes, IM_ARRAYSIZE(modes));

    // Threshold visualization
    if (current_mode >= 3 && current_mode <= 7) {
        ImGui::Separator();
        ImGui::Text("Threshold: %.2f", get_threshold(current_mode));
        ImGui::Checkbox("Show Threshold Line", &show_threshold);
    }

    // Legend
    ImGui::Separator();
    draw_color_legend(current_mode);

    ImGui::End();
}
```

### Color Legend

Display context-appropriate legend for current mode:

```
Classification Mode:
  ■ Blue    - Mesh Optimal (18 clusters, 22K pts)
  ■ Orange  - Gaussian Optimal (21 clusters, 28K pts)
  ■ Gray    - Uncertain (3 clusters, 500 pts)

Planarity Mode:
  ■ Red (0.0) -------- Green (1.0)
  Threshold: 0.7 [-------|--]
```

## Requirements

### Functional

- [ ] Classification color mode with label colors
- [ ] Confidence gradient overlay
- [ ] Heat map mode for each metric (5 metrics)
- [ ] Cluster ID coloring
- [ ] Original SH color mode
- [ ] ImGui control panel
- [ ] Color legend display
- [ ] Mode persistence across sessions

### Performance

- [ ] Mode switching < 100ms
- [ ] No frame rate impact from color computation
- [ ] Pre-compute colors on classification change

## Data Flow

```
Scene + ClassificationResults
         │
         ▼
┌─────────────────────┐
│  Color Computation  │  Per-primitive color based on mode
└─────────────────────┘
         │
         ▼
┌─────────────────────┐
│  Polyscope Update   │  cloud->updateColorQuantity()
└─────────────────────┘
         │
         ▼
      Display
```

## API

```cpp
namespace geode {

enum class ColorMode {
    ORIGINAL,
    CLASSIFICATION,
    CONFIDENCE,
    PLANARITY,
    EFFECTIVE_RANK,
    ALPHA_MEAN,
    ALPHA_VARIANCE,
    NORMAL_COHERENCE,
    CLUSTER_ID
};

class VisualizationController {
public:
    void set_mode(ColorMode mode);
    ColorMode get_mode() const;

    void update_colors(polyscope::PointCloud* cloud,
                       const Scene& scene,
                       const std::vector<ClassificationResult>& results);

    void draw_ui();

private:
    ColorMode mode_ = ColorMode::ORIGINAL;
    std::vector<glm::vec3> cached_colors_;
};

}  // namespace geode
```

## Test Cases

| Test | Action | Expected |
|------|--------|----------|
| Mode switch | Change to Classification | Colors update immediately |
| Confidence | View low-confidence cluster | Pale/desaturated color |
| Heat map | Planarity mode | Smooth gradient, threshold visible |
| Cluster ID | 50 clusters | 50 distinct colors |
| Large scene | 500K points, mode switch | < 100ms update |

## Notes

- Colors are per-primitive, not per-cluster (for smooth boundaries)
- Confidence affects saturation, not hue (preserves label identity)
- Heat maps use perceptually uniform color scales where possible
- Original color mode useful for comparing with 3DGS viewer
